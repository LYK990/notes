# vue3源码

## 模块组织方式及结构

<img src="images/image-20221013222712852.png" alt="image-20221013222712852" style="zoom: 67%;" />

编译部分： compiler-dom 	compiler-core	compiler-sfc

运行时：runtime-dom	runtime-core	reactivity

### reactivity的核心流程

effect依赖收集、触发依赖

 template编译成render函数



## vue3源码知识

### vue3自定义渲染器

### vue3源码分为两个部分

- 编译部分
- 运行时

挂载到vue对象上时，tree shaking就没用了 ，因为tree shaking无法分辨用还是没用 

teleport 内置组件

vue3 return出ref时会自动的进行解构，所以在模板中就不用写.value

computed计算出来的值 和 ref 没有区别。

watch观察对象值的改变需要进行一个深拷贝

setup = beforecreate 和 created

**ref**

- :ref = (el) => {if(el) => lis[i] = el}
- const li = ref(null)

结构ref类型会造成响应式数据丢失，可以用torefs解决  

vite 的开发环境用的是esbuild 生产用的rollup

weakMap() 不会导致内存泄漏 弱引用

Reflect的作用是让this依旧指向代理对象

### watch

**watch和watcheffect的区别**

![](images/image-20220726222630858.png)

watch监控对象无法区分前后的新值和老值。watch1的本质就是effect，内部会对用户填写的数据进行依赖收集

watch的第一个参数，用回调函数把当前需要监控的变量保存起来

## 手写Vue3

```shell
# 生成tsconfig
npx tsc --init

# 转译node环境
yarn add --dev babel-jest @babel/core @babel/preset-env

# ji'x
yarn add --dev @babel/preset-typescript
```

### effect & reactive 

effect收集依赖

```javascript
const targetMap = new Map();
export function track(target, key) {
  //   target -> key -> dep
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    depsMap = new Map();
    targetMap.set(target, depsMap);
  }

  let dep = depsMap.get(key);
  if (!dep) {
    dep = new Set();
    depsMap.set(key, dep);
  }
  dep.add(activeEffect);
  // const dep = new Set()
}
```

