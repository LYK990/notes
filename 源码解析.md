#  vue3源码

## 模块组织方式及结构

<img src="images/image-20221013222712852.png" alt="image-20221013222712852" style="zoom: 67%;" />

编译部分： compiler-dom 	compiler-core	compiler-sfc

运行时：runtime-dom	runtime-core	reactivity

### reactivity的核心流程

effect依赖收集、触发依赖

 template编译成render函数

rollup一般用于库的打包，而webpack一般用于应用的打包

## vue3源码知识

所有的逻辑操作都会基于虚拟节点（vnode）来做处理

### vue3自定义渲染器

### vue3源码分为两个部分

- 编译部分
- 运行时

挂载到vue对象上时，tree shaking就没用了 ，因为tree shaking无法分辨用还是没用 

teleport 内置组件

vue3 return出ref时会自动的进行解构，所以在模板中就不用写.value

computed计算出来的值 和 ref 没有区别。

watch观察对象值的改变需要进行一个深拷贝

setup = beforecreate 和 created

**ref**

- :ref = (el) => {if(el) => lis[i] = el}
- const li = ref(null)

结构ref类型会造成响应式数据丢失，可以用torefs解决  

vite 的开发环境用的是esbuild 生产用的rollup

weakMap() 不会导致内存泄漏 弱引用

Reflect的作用是让this依旧指向代理对象

### watch

**watch和watcheffect的区别**

![](images/image-20220726222630858.png)

watch监控对象无法区分前后的新值和老值。watch1的本质就是effect，内部会对用户填写的数据进行依赖收集

watch的第一个参数，用回调函数把当前需要监控的变量保存起来

## 手写Vue3

```shell
# 生成tsconfig
npx tsc --init

# 转译node环境
yarn add --dev babel-jest @babel/core @babel/preset-env

# ji'x
yarn add --dev @babel/preset-typescript
```

### reactivity

#### effect

````javascript
// 依赖收集 -> 注册副作用函数的一个方法
````

#### reactive

````javascript
export function reactive(raw) {
    return new Proxy(raw, {
        get(target, key) {
            const res = Reflect.get(get, key)
            return res
        },
        set(target, key, value) {
            const res = Reflect.set(target, key, value)
            retrun res
        }
    })
}
````

#### track

```javascript
// 依赖收集
// 触发get的时候会收集依赖
// 触发set的时候会触发依赖
const targetMap = new Map();
export function track(target, key) {
  //   target -> key -> dep
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    depsMap = new Map();
    targetMap.set(target, depsMap);
  }

  let dep = depsMap.get(key);
  if (!dep) {
    dep = new Set();
    depsMap.set(key, dep);
  }
  dep.add(activeEffect);
  // const dep = new Set()
}
```

#### trigger

````JavaScript
// 触发更新
export function trigger(target, key) {
    let depsMap = targetMap.get(target)
    let dep = depsMap.get(key)
    
    for(const effect of dep) {
        effect.run( )
    }
}
````

#### ref

````javascript
class RefImpl {
  private _value: any;
  public dep;
  private _rawValue: any;
  private _v_isRef = true;
  constructor(value) {
    this._rawValue = value;
    // 查看value1是否是一个对象
    this._value = covert(value);
    this.dep = new Set();
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newValue) {
    // 已经先去修改了value的
    // hasChange
    if (hasChanged(newValue, this._rawValue)) {
      this._rawValue = newValue;
      this._value = covert(newValue);
      triggerEffects(this.dep);
    }
  }
}  

export function ref(value) {
    return new RefImpl(value)
}

````

#### computed

````javascript
class ComputedRefImpl {
  private _getter: any;
  private _dirty: Boolean = true;
  private _value: any;
  private _effect: any;
  constructor(getter) {
    this._getter = getter;
    this._effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
      }
    });
  }
  get value() {
    // get
    // get value -> dirty true
    // 当依赖的响应式对象的值发生改变的时候
    // effect
    if (this._dirty) {
      this._dirty = false;
      this._value = this._effect.run();
      // this._value = this._getter()
    }
    return this._value;
  }
}

export function computed(getter) {
  return new ComputedRefImpl(getter);
}
````

