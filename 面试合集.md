# 计算机组成原理

## CPU



# 计算机操作系统

## 内存

内存是存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。

平时各种各样的软件都是存储在外存中的，电脑中的外存指的硬盘，硬盘是一种慢速的设备，而内存是一种超快速的设备。将需要运行的各种各样的软件都放到内存里，cpu直接从内存中存取这些设备。

内存分为内存地址和存储单元，每个内存地址对应一个存储单元。内存的存储大小要看是按字节还是按字编址，如果计算机**按字节编址**，每个存储单元大小为1字节（1B），如果字长为16位的计算机**按字编址**，则每个存储单元大小为1个字，每个字的大小为16个二进制位。

（进程由三个部分组成，程序段、数据端还有PCB），写的代码经过编译之后会形成对应的机器指令，而这些指令会放在内存中，cpu根据内存中程序段中一系列的指令来完成事情，

编译其实就是把高级语言编译成机器语言，编译程序会将用户的源代码编译成多个目标模块，，由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一整个的装入模块，再由装入程序将装入模块装入内存中运行。

内存不够时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘空间动态调度）。

（单一连续分配）

（固定分区分配）为了能在内存中装入多道程序，且这些程序不会相互干扰，于是就将内存分配成了多个分区，在每个分区中只装入一道作业。操作系统建立了一个分区说明表，来实现各个分区的分配和回收。每个表项包括分区的大小、起始地址、状态（是否已分配）。当用户要装入内存的时候，操作系统就会根据分区说明表，从其中找到一个满足大小未分配的分区，分配给该程序，然后修改状态为已分配。

（动态分区分配）在进程装入内存的时候，根据进程的大小动态的创建分区。使分区的大小正好适合进程的需要，这种分配方式会建立一个空闲分区表，表项 中包含分区号、 分区大小、分区 起始地址等信息。

在一开始给多个进程分配分区时，这些进程在内存中是紧挨着的，随着多次回收和分配，进程在内存中会变成离散分布，并可能出现大量外部碎片。动态分区不会产生内部碎片，因为每个分区大小都等于该进程所需内存大小。

此时可以用**紧凑**技术解决，将离散的进程变成在内存中紧密相连，**紧缩是指将所有进程占用的分区移动到一端使其紧凑的挨在一起，空闲区留在另一端**。

## 栈和堆的区别

cpu中有个核心模块叫ALU,专门用来做逻辑运算，如果算式比较复杂，没法一次性算出结果，会先计算，得到一个临时结果，这就需要将临时结果找个地方存放一下，这个玩意就叫寄存器。

为了降低cpu设计的复杂性以及成本，但同时又为了实现更复杂的计算，需要在内存中划分一个专门的区域用来存放临时数据。

栈和堆本质上都只是内存中的一片区域。从栈中取出数据的时候会先复制到cpu中的寄存器，出栈时这个数据还在堆栈里，但是已经被当作垃圾了。

在多线程环境下每一个线程都可以有他自己完全的独立的栈，但是他们共享堆。并行存取被堆控制而不是栈

**栈:**

1. 和堆一样存储在计算机 RAM 中。
2. 在栈上创建变量的时候会扩展，并且会自动回收。
3. 相比堆而言在栈上分配要快的多。
4. 用数据结构中的栈实现。
5. 存储局部数据，返回地址，用做参数传递。
6. 当用栈过多时可导致栈溢出（无穷次（大量的）的递归调用，或者大量的内存分配）。
7. 在栈上的数据可以直接访问（不是非要使用指针访问）。
8. 如果你在编译之前精确的知道你需要分配数据的大小并且不是太大的时候，可以使用栈。
9. 当你程序启动时决定栈的容量上限。

**堆：**

1. 和栈一样存储在计算机RAM。
2. 在堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放。
3. 相比在栈上分配内存要慢。
4. 通过程序按需分配。
5. 大量的分配和释放可造成内存碎片。
6. 在 C++ 中，在堆上创建数的据使用指针访问，用 new 或者 malloc 分配内存。
7. 如果申请的缓冲区过大的话，可能申请失败。
8. 在运行期间你不知道会需要多大的数据或者你需要分配大量的内存的时候，建议你使用堆。
9. 可能造成内存泄露。

进程的堆用于动态内存分配，即存放编译时大小未知的变量。和能够自动释放的栈不同，堆由用户进程自行管理，堆内的变量需要显式释放（free指令），否则该变量会一直存在于内存中，一直不释放会造成内存泄漏。

## 进程和线程

### 进程

早期计算机运行程序时只能一次运行一个程序，而且所有的系统资源（如CPU、内存和IO设备等）都由该程序单独使用，在该程序运行完之前其他程序无法运行，这就是单道程序设计。

**单道程序系统**的内存中除了操作系统这个内核程序之外，只有一个用户程序在内存中。其缺点时浪费资源且程序运行效率低。

**多道程序设计**允许内存中存放多道程序，它们在操作系统的调度下交替的在CPU上运行从而实现程序的并发，提高了程序执行的效率和资源利用率。

由于计算机中有多道程序，因此内存中保存了多个程序的程序段和数据段，操作系统如何才能找到各个程序程序段和数据段的位置？计算机里的设备分配给不同的程序，如何知道哪些设备被哪些程序占用？CPU运行一个程序A运行到一半就切换到另一个程序，程序A的CPU环境或者说它的运行状态和进度存放到哪里？

为此，操作系统为每一个要投入运行的程序设置了一个PCB（进程控制块）的结构来保存上述的程序控制信息。由此，也引出了进程的概念，多道程序设计中程序的并发执行就是通过进程实现的。

**进程是程序的一次执行过程，是系统进行资源分配和调度的单位**。

**一个进程实体（进程映像）由数据段、程序段和PCB三部分组成，它们离散的存储在内存中**。

PCB保存了所有操作系统管理和控制该进程所需的控制信息

进程分为几种状态

**运行状态**：当前进程已经分配到CPU的状态。处于这种状态的进程数不会大于计算机CPU的个数。

**就绪状态**：进程已具备运行条件和所有所需资源但唯独没有分配到CPU的状态，一旦CPU空闲，该进程就有机会获得CPU控制权进入运行状态。

**阻塞状态**：进程因等待某种事件而暂时不能运行的状态（如等待某个输入或输出、等待其他进程发来的信号等）。即使CPU空闲也无法获取其控制权。

**新建状态**：进程正在被创建，操作系统正为进程分配资源 和 初始化PCB的状态。

**终止状态**：进程完成自己任务正常终止或遇到错误被迫终止或人工干预终止时，操作系统正回收进程的资源，撤销PCB过程的状态。

### 线程

一个进程可能也需要同时处理多个任务，例如QQ软件可能要同时运行视频聊天的处理程序，也要运行传送文件程序。

为了满足这种需求，操作系统引入了线程，进程就不再是运行调度的最小单位，而只是资源分配的单位，线程变成了运行调度的最小单位（作为CPU的分配单元），同一个进程内的线程之间可以并发，不同进程之间（的线程）也可以并发

线程也有就绪、阻塞和运行这3种基本状态；

线程几乎不独立拥有系统资源，而是共享进程内的资源，但线程可以独立拥有CPU资源（一个进程内的多个线程可以在不同的CPU上并行运行证明线程可以拥有CPU资源）。

由于共享进程的内存空间，因此同一个进程中的线程间通信几乎无需系统干预；

切换同一进程的线程不会引起进程切换，开销很小；切换不同进程的线程会引起进程切换，开销大。

### 线程和进程关系

一个进程可以有多个线程，但至少要有一个线程；

一个线程只能在该进程的地址空间活动。

资源分配给进程，同一进程下的所有线程共享该进程所有资源。

同一进程中的多线程只能并发不能并行，因为他们只能运行在一个CPU上，用户程序在同一个进程时间片内切换多个线程

### 进程间关系

互斥：多个并发进程需要共享资源时，宏观或微观上一段时间内进程只能交替使用这个资源，而不能共享这个资源，我们称多个进程互斥访问资源。

同步：多个并发进程合作完成一个任务的过程中，不同进程的子任务是相互依赖的，让无序的进程（异步性）按指定顺序完成各自的任务从而完成整体任务就是同步。

## 操作系统中进程和线程怎么通信

### 进程通信的方式

- **共享内存**：共享内存是在内存分配一块空间作为多个通信进程的共享存储区，**需要通信的多个进程把共享存储区附加到自己的地址空间**就可以对共享存储区读写，多个进程对共享空间的访问是互斥的，通过操作系统提供的互斥工具实现互斥，因此进程间共享需要系统介入，
- **管道通信：**管道是用于连接读写进程的一个共享文件（又称pipe文件），其本质是OS在内存中开辟的一个大小固定的缓冲区（通常为一个内存页大小，约为4K）。读写进程可以通过该共享文件传递数据。
  -  管道采用半双工通信，某一时间段内只能实现单向传输
  - 写进程写的时候，读进程不能读，必须写完之后，写进程释放管道，读进程才能从管道读
  - 数据以字符流的形式写入管道。管道写满时，写进程执行write()系统调用会阻塞进程，直到管道有空间写入；管道读空时，读进程执行read()系统调用会阻塞进程，直到管道有数据到来；
  - 如果没写满，则不允许读；如果没读空，就不允许写
  - 数据一旦被读出，就会被管道抛弃
- **消息传递：**（忽略）



# 计算机网络

## TCP三次握手和四次挥手

#### 三次握手

一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。TCP的头部包含源端口号、目的端口号、序列号等，TCP是传输层协议。全双工通信，三次握手是建立连接时的准备工作，其实就是把自身的序列号发送给对方（**syn~ack~ack**），看对方能不能收到。最开始服务器监听某个端口，客户端发送syn包，可以建立连接之后服务端返回syn+ack包，客户端再发送ack包。

tcp连接会建立一个发送缓冲区，第一个自己的序列号是0，后面的每个字节的序列号就会增加1，

- 发送数据时就会从发送缓冲区取一部分数据组成发送报文，在tcp协议头中会附带序列号和长度。
- 接受端在收到数据后需要回复确认报文，确认报文ack=接受序列号+长度，也就是下一包（**客户端**）需要发送的起始序列号
- 发送端可以发送一次连续的多包数据。接收端只需要回复一次ack就可以了。
- 这样发送端可以把一系列的数据切割成碎片发送给服务端
- 服务端根据序号和长度在接受后重构出来完整的数据
- 数据包丢失，客户端可以重传

#### 四次挥手

客户端和服务端都可以先发起关闭请求

- 客户端向服务端发起关闭请求，需要向服务端发送fin包，客户端禁止终止等待1状态， （第一次挥手）
- 服务端发送ack包，表示服务端进入了关闭等待状态
- 客户端进入终止等待2状态，（第二次挥手）
- 服务端发送fin包进入最后确认状态 （第三次挥手）
- 客户端收到之后回复ack包，进入超时等待状态（为了保证服务端收到ack包），经过超时时间之后关闭连接，而服务端收到ack包后立即关闭连接（第四次挥手）
- 超时等待是为了保证服务端已经收到ack包，假设客户端发送了最后一包ack包后就释放了连接，一旦ack包在网络中丢失，服务端将一直停留在最后确认状态。如果客户端发哦是那个最后一包ack包后，等待一段时间，这时服务端因为没有收到ack包，会 重发fin包。客户端会响应这个ack包并刷新超时时间。

#### TCP为什么不能两次握手

两次握手只能保证客户端的序列号成功被服务端接收，而服务端是无法确认自己的序列号是否被客户端成功接收。所以是不行的

第一次发送syn包时，如果丢了，客户端发第二次，服务端返回syn+ack，此时建立连接，但是如果第一次恢复了。服务端就会误以为又要建立连接了。此时客户端认为时两次连接，而服务端任务时一次连接，造成状态不一致。

第三次握手，如果客户段没有收到最后的syn包，就不回认为连接成功

## UDP和TCP的对比

只要在网络层使用ip协议，就可以接入到使用tcp/ip体系的网络中，

真正通信的实体是主机中的应用进程互相通信。tcp/ip的运输层使用端口号来区分不同的应用进程

UDP： 

- 无连接，（在传输前不需要建立连接，通信双方可随时发送数据）
- 支持一对一，一对多和多对一、多对多交互通信（单播、广播、多播）
- 对应用层交付的报文直接打包
- 尽最大的努力交付，也就是不可靠；不使用流量控制和拥塞控制
- 首部开销小，仅8字节

TCP：

- 面向连接
- 每一条TCP连接只能有两个端点EP，只能是一对一通信
- 面向字节流
- 可靠传输、使用流量控制和拥塞控制
- 首部最小20字节，最大60字节。

## 输入⼀个URL发生了什么

### 1.用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
- 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。

当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态（loading）。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为需要跳转的页面。因为需要等待提交文档阶段，页面内容才会被替换。

### 2.URL请求过程

接下来，便进入了页面资源请求过程。这时，浏览器主进程收到了地址栏的用户输入，

**因为浏览器是分为**

- **Browser(一个) - 浏览器进程**, 只有一个浏览器进程，负责浏览器的主体部分，包括导航栏，书签， 前进和后退按钮, 提供存储等功能
- **Network(一个) - 网络进程**, 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
- **GPU(一个) - 图像渲染进程**, 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。
- **GPU(一个) - 图像渲染进程**, 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。
- **GPU(一个) - 图像渲染进程**, 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。
- **Extensions(多个) - 扩展程序进程**
- **其他进程** - 工具进程，辅助框架等等

浏览器发起请求是需要调用网络进程的，因为进程之间的内容是需要相互隔离的，进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，当需要跨进程通信的时候，浏览器进程会通过进程间通信机制（IPC）把 URL 请求发送至网络进程。

网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。

**DNS解析**

因为ip地址是一种用于互联网上访问内容的虚拟地址，要想访问他人的网络就要记住ip地址才行，因为互联网不能通过域名直接访问，系统就会去hosts文件里，去查询这个域名对应的ip地址是什么。然后电脑会去访问这个ip。因为电脑不可能保存所有的域名和对应的ip地址。所以单独出来了一个服务器，让服务器去专门存储这个世界上绝大多数域名和ip的映射表，这个服务器就是dns服务器。

如果请求协议是 HTTPS，那么还需要建立 TLS 连接。

接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

**在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。**

#### 响应数据处理

在处理了跳转信息之后，我们继续导航流程的分析。然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

#### 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

**那什么情况下多个页面会同时运行在一个渲染进程中呢？**

要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

```javascript
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

总结来说，打开一个新页面采用的渲染进程策略就是：

- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

#### 提交文档

所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：

- 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
- 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

其中，当渲染进程确认提交之后，更新内容如下图所示：

![image-20221005134118852](images/image-20221005134118852.png)

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

#### 渲染阶段

一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。

渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。

渲染进程里面有：一个主线程（main thread），几个工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅线程（raster thread）

在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。

##### 构建Dom

渲染进程在导航结束的时候会收到来自浏览器进程提交导航的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据，并把它转化为一个DOM（Document Object Model）对象。

##### 子资源加载

除了HTML文件，网站通常还会使用到一些诸如图片，CSS样式以及JavaScript脚本等子资源，这些文件会从缓存或者网络上获取。

主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起网络请求，为了提升效率，浏览器会同时运行“预加载扫描”程序。

如果在HTML文档里面存在诸如<img>或者<link>这样的标签，预加载扫描程序会在HTML解析器里面找到对应要获取的资源，**并把这些要获取的资源告诉浏览器进程里面的网络线程**

##### JavaScript会阻塞HTML的解析过程

当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。

为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如document.write()这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。

开发者可以通过很多方式告诉浏览器如何才能更加优雅地加载网页需要用到的资源。比如你可以为script标签添加一个async或者defer属性来使JavaScript脚本进行异步加载。<link rel="preload">资源预加载可以用来告诉浏览器这个资源在当前的导航肯定会被用到，你想要尽快加载这个资源。

##### 样式计算 CSS

主线程会解析页面的CSS从而确定每个DOM节点的计算样式（computed style）。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，每个DOM节点还是会有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。
因为这个样式表的存在，页面上的h1标签一定会比h2标签大，而且不同的标签会有不同的magin和padding

##### 布局 Layout

前面这些步骤完成之后，渲染进程就已经知道页面的具体文档结构以及每个节点拥有的样式信息了，可是这些信息还是不能最终确定页面的样子.

只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要通过布局（layout）来计算出每个节点的几何信息。

布局的具体过程是：

1. 主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。
2. 布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。

举个例子，如果一个节点被设置为了display:none，这个节点就是不可见的就不会出现在布局树上面（visibility:hidden的节点会出现在布局树上面）。同样的，如果一个伪元素（pseudo class）节点有诸如p::before{content:"Hi!"}这样的内容，它会出现在布局上，而不存在于DOM树上。

##### 绘画

知道了DOM节点以及它的样式和布局其实还是不足以渲染出页面来的。

为什么呢？举个例子，假如你现在想对着一幅画画一幅一样的画，你已经知道了画布上每个元素的大小，形状以及位置，你还是得思考一下每个元素的绘画顺序，因为画布上的元素是会互相遮挡的（z-index）。

如果页面上的某些元素设置了z-index属性，绘制元素的顺序就会影响到页面的正确性。

##### 合成

浏览器已经知道了关于页面以下的信息：文档结构，元素的样式，元素的几何信息以及它们的绘画顺序。那么浏览器是如何利用这些信息来绘制出页面来的呢？将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）。

现代浏览器采用合成的方式, 来展示整个页面

合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。



## https原理

### https握手过程

#### HTTPS 和 HTTP 的缓存有什么区别

## websocket和socket区别

## websocket和http区别

## http和https的区别

## 跨域

### 本地服务代理为什么能解决跨域问题?跨域问题的其他解决方法了解过吗?

## 强缓存、协商缓存、CDN缓存

### cache-control 有哪些字段？设置 max-age: 0 跟浏览器缓不缓存有关系吗？s-max-age 的作用？

### 强缓存和协商缓存的顺序

##  Cookie 有哪些字段

## 跨域时如何处理cookie

## DNS解析会出错吗，为什么

## TCP有哪些手段保证可靠交付

## 如何应对流量劫持

## http2的多路复用

# vue3

## 响应式原理

## diff算法

## 生命周期

## 虚拟dom

## 单页面应用和多页面应用的区别及优缺点

## vuex解决了什么问题

###  Vuex 的 Mutation 和 Action 的区别

### 为什么要设计出 Mutation 和 Action 这两个东西

## 如何使用 react/vue 实现一个 message API

## 虚拟dom为什么快

## 如何设计一个组件

## 如何做到的双向绑定

## VueRouter原理

### 对于 History 路由而言，你觉得在服务端是如何做路由分发的呢

## 一个for循环中改变当前组件依赖的数据，改变一万次，会有什么效果？(批量更新和 nextTick 原理）

## vue组件销毁时，所有自定义事件和原生事件都会跟着解绑吗

## vue3是怎么解决vue2的响应式缺陷的

## vuex是怎么做到将数据注入到每一个组件里的?

# HTML+CSS

## CSS重绘重流

# JavaScript

## 作用域链

## 原型

## 执行上下文和执行栈

## 闭包

## js事件机制

## 怎么做并发请求

## 图片懒加载

## 垃圾回收机制

## 怎么解决闭包陷阱

## async await 经过编译后和 generator 有啥联系？

### async和await是怎么做到串行执行异步操作的

##  Promise的then方法为什么能链式调用

## 一个超长字符串能存在栈内存里面吗

## webworker开一个子线程，那怎么监听子线程挂了

## axios拦截器如何拦截请求错误或者响应错误

## 如何设计一个渲染引擎

# Typesctipt

## typescript有什么好处

# Webpack

## webpack打包原理

## 随着 http2 的发展，webpack 有没有更好的打包方案

## webpack 热更新原理

# Web安全

## 如何预防中间人攻击

# Node

## require的模块加载机制

### require的实现原理

## Node如何实现热更新

## 异步IO

## 垃圾回收机制

## 父进程或子进程的死亡是否会影响到对方？什么是孤儿进程？

## 消息队列

## ssr的实现原理

## 为什么客户端渲染会首屏加载过慢

## 在 Node 应用中如何利用多核心CPU的优势

## node中cluster是怎样开启多进程的，并且一个端口可以被多个进程监听吗

## node进程中怎么通信

## node可以开启多线程吗

## JWT优缺点

# 前端部署

## Docker

## Nginx

## CI/CD

### 前端如何进行多分支部署

# 前端构建

## package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明

## ESModule 既然是编译时加载，那它可以做到运行时加载吗



# 前端监控

## 性能监控

## 埋点

## 服务器监控

## 异常处理

# 前端性能优化

## 首屏渲染

## 如何提升页面加载速度，简述原理

```` javascript
合并压缩js、css⽂件
延迟加载不需要的资源
使⽤sprites合并细碎的⼩图⽚
使⽤内嵌的base64图⽚代替url
对静态资源使⽤CDN
合理配置缓存策略
服务端启⽤gzip
⽀持http2
减少阻塞脚本，使⽤async
ssr后端渲染
减少重定向
````

## 文件上传如何做断点续传

# 前端架构设计

## 一个大型项目如何分配前端开发的工作

## 如果每次要生成不一样的 ID，你怎么来设计这个系统呢

## 中后台应用如何在高重复性页面开发中通过技术方案提高开发效率

## 中后台业务

## 对前端架构的认识，如何设计出一个架构方案

# 浏览器

## 浏览器渲染过程

## 优雅降级和渐进增强

## Chrome为什么从单进程转成多进程架构

## 知道哪些进程间通信(IPC)的方式

## 线程安全

## 如果要在UI渲染之前做一些事情你会怎么办

## 分离图层做动画有什么好处

### 分离图层会发生重绘吗？(会)那既然重绘，它的好处在哪里？(不会影响其他的图层)

# 业务

## 有没有做一些提高开发效率的问题

## 技术难点

## 有没有复杂业务经验，**难点在哪里**

## 这个项目的业务背景是什么，

## 在业务上有什么比较牛逼的地方，推动了业务如何运行

## 技术实现上：这个项目的整体技术实现思路是怎样的，

## 项目中用了什么比较牛逼的技术，解决了什么比较困难的问题

# 开发技术

## vue和react谈谈区别和选型考虑

## CORS 如何设置，有哪些细节

## 图片防盗链原理

## SSR和bff的理解

## 事件循环机制，node和浏览器的事件循环机制区别

## 如何解决同步调用代码耗时太高的问题

## 对MVC、MVP、MVVM的理解

## 歌曲倍速播放的功能是怎么实现的？

## AMD 和 ESModule 有什么区别

## 设计一个适配 PC、手机和平板的项目，你有哪些布局方案

## 1px问题

## 不同浏览器兼容性问题

## 在一个大型项目中，如何定位发生内存泄露的代码

## 服务端和客户端怎么同步状态

