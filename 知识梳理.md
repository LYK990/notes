# JavaScript

## 原型和原型链

只有函数对象才有prototype**‘属性’**，原型对象上才有constructor属性，实例化对象才有__proto__属性

* new做了什么（资源共享、节约内存）

  * 开辟新的空间

* 修改this指向到这个空间

  * 执行构造函数

* 即使没有出现严格模式指令，class声明体中的所有代码也默认处于严格模式。

## 执行上下文

**执行上下文栈**

- JavaScript 引擎创建了执行上下文栈来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。

- JavaScript 执行在单线程上，所有的代码都是排队执行。

- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。

- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。

- 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。

- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。

- 执行上下文栈永远都有一个全局执行上下文（因为JavaScript开始解析代码的时候最先遇到的就是全局执行上下文）

**全局执行上下文**

 javascript 引擎并非一行一行地分析执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升

## 作用域

## 闭包

## 单线程

### 进程和线程

### 异步

# node

## 模块机制

##  异步IO

单线程仅仅只是JavaScript执行在单线程中罢了，其实Node自身其实是多线程的

nodejs其实只有js执行是单线程，I/O显然是其它线程。js执行线程是单线程，把需要做的I/O交给libuv

WebWorkers能解决利用CPU和减少阻塞UI渲染，但是不能解决UI渲染的效率问题

# 计算机网络

