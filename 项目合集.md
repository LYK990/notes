

# 博客(SSR)项目

vue2中，给组件绑定的事件都是自定义事件，想要原生Dom事件就要加.native。vue3中 给组件绑定的事件都是原生Dom事件，如果想要自定义事件 组件内通过emits声明接收事件emits：[]

加上scoped就会自动删除未引用的样式

浏览器不能直接解析ts  tsc-v， 浏览器无法直接解析ts文件，需要先将.ts文件编译成.js文件。

css.modules  返回相应的模块对象

scoped是通过postcss组件实现的，postcss会对对代码进行一次代码转换，scoped为组件上的类添加了data-   （自定义属性）

object.freeze()可以冻结一个对象，一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性。freeze冻结的是堆内存中的值，和栈中的引用无关。vue的源码，定义响应式的时候，如果freeze后的数据，不会加上setter和getter。

npm 是 node 软件包的管理器

npx 是 node 软件包的执行工具  官方文档，从npm@5.2.0 版本开始，npx就和npm捆绑在了一起，可以认为npx是npm 的高级版本，npx 具有更强大的功能，

**npx**：

- npx 的原理很简单，就是运行的时候，会到`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。由于 npx 会检查环境变量`$PATH`，所以系统命令也可以调用。
- 除了调用项目内部模块，npx 还能避免全局安装的模块。

## 部署

Jest 不支持 ES6 语法，不能使用 import 引入，只支持 commonjs规范。（需要配置插件才能使用ES6语法）

- jest 中有 babel-jest 组件，当我们使用 jest 命令时，会先去检测根目录或者开发环境中有没有安装 bebal 核心包，检测到后再去找 babelrc 文件，找到之后进行转换，转换后再执行用例测试。

**jest和ts-jest 和babel-jest要对应版本**

- .babelrc 和babel.config.js冲突

项目打包： 修改build 打包命令

```
"serve": "vite",
    "build": "vite build",
    "preview": "vite preview",
```

## 宝塔

- 修改云服务器的端口范围

npm找不到cli文件

```
去node目录下：/node***(你的版本)/bin
shell> rm npm
shell> ln -s ../lib/node_modules/npm/bin/npm-cli.js ./npm
```

打开端口

pm2 安装需要软连接，，，软连接的文件在node的目录下

数据库配置后记得重启

## 前端项目

axios返回来的数据会默认带一个data

服务端渲染 router 使用 import.meta.env.SSR ? createMemoryHistory() : createWebHistory(),

state要占位 index.html

window.location.href

css 预加载？

数据预取？？

```
 "babel": "babel src --out-dir dist --extensions \".ts\""
 
  // "@babel/cli": "^7.17.6",
    // "@babel/core": "^7.17.9",
    // "@babel/preset-env": "^7.16.11",
    // "@babel/preset-typescript": "^7.16.7",
```

- 404路由
  - 404 路由 必须要写到最后一项
  - vue3使用/:pathMatch(.*)

css 文件预加载

this.$router.options.routes    // 拿的是最开始注册的路由

router.getRoutes() // 拿取动态添加后的路由

websocket  blob使用 

meta seo优化

- 使用占位+state.routes 拿取路由中的meta的信息+模板字符串

## 后端项目

bearer token 、、、、这样写token才能生效  const reader = new FileReader();

### koa

koa2中的get传值通过request接收，但是接受的方法有两种query和querystring。

- query：返回的是格式化号的参数对象 {name ： ‘123}
- querystring：返回的是请求字符串  name=123&&age=123

ejs 模板引擎

## 需要添加的功能

### websocket

### 性能监控

### 测试

### 手写脚手架

# [mini-vite](https://github.com/lyk990/mini-vite)

功能实现

- 使用monorepo管理项目

- `依赖预构建`的功能，通过 Esbuild 实现依赖扫描和依赖构建的功能。
- 搭建 Vite 的插件机制，开发 `PluginContainer` 和 `PluginContext` 两个主要的对象。
- 发一系列的插件来实现 no-bundle 服务的编译构建能力，包括入口 HTML 处理、 TS/TSX/JS/TSX 编译、CSS 编译和静态资源处理。
- 实现一套系统化的模块热更新的能力，从搭建模块依赖图开始，逐步实现 HMR 服务端和客户端的开发。

## 项目实现

 *run*-*s* run-p ，其中后两个都是 npm-run-all 带参数的简写，分别对应串行和并行

### [搭建monorepo架构](https://blog.xueqimiao.com/vue/source3/3caf25/#monorepo%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA)

- 创建pnpm-workspace.yaml文件或者在package.json中增加package

```js
packages:
  - 'packages/*'
  - 'playground/**'
  - 'mini-vite-example'
  - '!**/test/**'
```

- 在根目录安装依赖需要加上-w

```bash
pnpm i rollup -w
```

### 配置rollup

## 知识总结

### HTTP缓存（Etag）

#### 协商缓存的实现：从 Last-Modified 到 Etag

Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers

````js
Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
````

随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：

````js
If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
````

服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。

使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：

- 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。
- 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。

Etag 是由服务器为每个资源生成的唯一的**标识字符串**，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个🌰，它可以是这样的：

````js
ETag: W/"2a3b-1602480f459"
````

那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：

````js
If-None-Match: W/"2a3b-1602480f459"
````

Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 **Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。**

# vite插件开发

## 计算依赖大小，并自动生成文件

# 实现一个框架

## fearure

- CLI 命令行工具；
- 基于 React 的默认 UI 主题；
- 现代化的完整前端工作流；
- 海量构建插件实战，包括 Vite 插件、Babel 插件、Markdown 编译插件；
- 基于 Islands 架构的 SSR 构建与运行时系统。
